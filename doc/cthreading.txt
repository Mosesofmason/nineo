截取了一段算法部分翻译了一下, 翻的好累啊...

算法没有完全理解, 所以翻译的肯定会有错误, 你大概看看吧


+++++++++++++++++++++++++++++++++++++++++++++


定义:

    * 一个容器对象由下列区域组成 :

            Message message;           	// (可以是空)
            Container parent; 	
            Container child; 	// 第一个子节点
            Container next; 	// 兄弟节点中的下个元素, 或空

    * 帖子对象中我们感兴趣的是下面几个属性:

            String subject;           	
            ID message_id; 	// 帖子的 ID
            ID *references; 	// 上层帖子的 ID 列表

      References 的内容通常来自信头的 ``References'' 和/或
      ``In-Reply-To'' 区域. 如果两个同时存在, 就从 In-Reply-To 中找到第
      一个像 Message-ID 的内容并把它加到 References 里.

      如果 In-Reply-To 内找到多个 Message-ID, 只用第一个: 可能后面找到
      的都是 email 地址, 而非ID.

      ID 对象可以是字符串,  或是其他有意义的可作比较的标记.

      标题字符串中只有两个部分需要注意: 查看是否以 ``Re:'' 开头, 以及比
      较除去 Re 後剩下的部分是否一样. 你可以 hashing 它们.  (这是一个很
      好的主意: 我的代码就是这样做的, 所以我可以在循环里用 == 代替
      strcmp.)

      出于同样的原因, ID 对象也不必一定是字符串. 它们可以是 hash 或是数
      字索引或是任何其他可以进行相等比较的标记, 所以你可以用比 strcmp
      快的多的指针相等比较.

      容器对象与帖子对象分离的原因是因为, 容器区域只在线索化消息时需要
      用到.: 你不必一直保留它, 所以不必在每个帖子结构体里都带着它们.

      * id_table 是一个结合容器与帖子 ID 的 hash 表.

      * 一个 ``空容器'' 是指一个没有帖子, 但有证据显示它存在的容器. 无
         论出于什么原因, 在我们的列表中没有帖子 (可能因为帖子过期或被
         canceled 了, 或是被从文件夹内删除, 或任何其他原因.)

      在展示时, 这些将以无选择的 ``父'' 容器加以展现, 举例来说, 如果我
      们有这样一个线索

            -- A
               |-- B
               \-- C
            -- D

      并且我们知道帖子 B 和帖子 C, 但它们的共同父节点 A 不存在, 那在 A
      处将有一个占位符, 将它们结合成一组, 以防止 D 成为 B 或 C 的兄弟节
      点.

      这些 ``哑'' 帖子只在深度 0 处出现. 

算法:

	1. 每个帖子:
	   1. 若 id_table 包括有这个 ID 的空容器:
              * 就在容器的 Message 处存储这个帖子. 
            否则:
		* 创建一个新容器对象来容纳这个消息;
               	* 在 id_table 里以 Message-ID 索引好这个容器. 

            2. 对于在帖子 References 区域的每个元素都:

	         * 找到给定的 Message-ID 对应的容器对象:
                     o 如果在 id_table 里存在就使用它;
                     o 否则, 构建 (并索引) 一个带空帖子的容器. 

                 * 以 References 信头的顺序连接 References 区域的容器.
                     o 如果它们已经连接, 就不改变当前连接.
		     
	             o 不要添加一个会产生循环的连接: 即, 在做出 A->B 的
   		       论断前, 搜索 B 的子节点以查看是否会到达 A, 也要
   		       搜索 A 的子节点以查看是否会到达 B. 如果任何一者
   		       作为另外一者的子节点可以被到达, 就不要连接它们.
	      
             3. References 元素中的最后一个就是这个帖子的父节点. 注意的
            是这个帖子可能已经有父节点了: 这种情况发生是因为我们曾在
            Reference 区域中见过这个 ID, 并假定了该区域中的另外一个 ID
            为父节点. 现在我们有了真实的帖子, 因此可以做出判断, 扔掉过
            去的父节点并使用现在的这个. 在父节点的子节点列表里找到对应
            的容器, 并取消之间的连接.

            注意 当帖子没有 references 区域, 但又有其他帖子将这帖作为
	    references 的非第一个元素(可能是谎言...), 就可能导致这帖丢
	    失父节点.

            总是要注意, ``父'' 和 ``子'' 区域要保持内部一致.

	2. 找到根集合.

       	   遍历 id_table, 搜集到无父节点的容器对象列表.

	3. 扔掉 id_table. 我们不再需要它.

	4. 修剪空容器.
	   递归根集合下的所有容器.
	   对每个容器:
		1. 如果它是一个空容器并且没有子节点, 就清掉它.

                Note: 一般情况下这个的节点不会产生, 但当两个帖子的
                References 行不一致时会发生. 举例来说, 假定 A 和 B 是帖
                子, 1, 2 和 3 是我们看不见的 references 帖子:

                  A references: 1, 2, 3
                  B references: 1, 3 

                此时产生岐义, 3 是 1 还是 2 的子节点? 所以, 依据处理顺
                序, 我们最后会得到

                  -- 1
                     |-- 2
                         \-- 3
                             |-- A
                             \-- B

                 或

                  -- 1
                     |-- 2            <--- 非根节点的无子节点容器!
                     \-- 3
                         |-- A
                         \-- B

                2. 如果容器没有帖子, 但有子节点, 移除这个容器并将它的子
                   节点提升到这个级别 (即, 将它们与现在的子节点列表结合.)

                不要将子节点提升到根集合 -- 除非只有一个子节点. 

   5. 按标题组合根集合.

      如果两个成员的根集合有相同的标题就合并它们. 这样没有 References
      信头的帖子也会被线索化 (至少扩展了可能.)
      
         1. 构建一个新的 hash 表, subject_table, 表内结合标题字符串和容
            器对象.

         2. 对根集合中的每个容器:

                * 找到子树的标题:
		
                      o 如果帖子在容器内, 标题就是帖子的标题.
		      
                      o 如果容器内无帖子, 那么这个容器至少有一个子容器,
                      使用那个容器内的消息的标题.
		      
                      o 划去 ``Re:'', ``RE:'', ``RE[5]:'', ``Re: Re[4]: Re:'' 等等.
		      
                      o 如果标题现在成了 "", 放弃这个容器.
		      
                      o 将容器放入 subject_table 当:
		      
                            + 表中无此主题的容器, 或
			    
                            + 这是一个空容器, 而旧的那个不是: 空的作为
                            根更好, 所以将它放入表中.
			    
                            + 表中容器有 ``Re:'' 版的同样标题的, 而这个
                            容器有非-``Re:'' 版标题. 用非-re 版的更好.

         3. 现在 subject_table 根集合的每个标题都有一个项目. 现在遍历根
            集合, 搜集不同处.

            对根集合的每个容器:

                * 找到容器的标题 (如上.)
                * 查看表中这个标题的容器.
                * 如果是空, 或就是这个容器, 那么继续.

                * 否则, 我们组合这个容器和表中项目. 有几种可能性:

                      o 如果都是哑的, 将一者的子节点添加到另外一者里,
                      然后移除现在的空容器.

                      o 如果一个是空容器一个非空, 将非空容器作为空容器
                      的子节点, 并将非空容器作为其他同主题 ``真'' 帖子
                      的兄弟节点 (即都是空容器的子节点.)

                      o 如果容器非空, 且那个帖子的主题不是以 ``Re:'' 开
                      始, 而这个容器帖子的主题是, 就将这个作为前者的子
                      节点.

                      o 如果容器非空, 且那个帖子的主题是以 ``Re:'' 开始,
                      但这个容器帖子的主题不是, 就将那个作为後者的子节
                      点 -- 它们的顺序拍反了. (某种意义上这是暗中发生的,
                      如果两个帖子, 一个有 Re: 一个没有, 没有 Re: 的那
                      个将会在 hash 表中, 而不管它们发现的顺序是如何的.)

                      o 否则, 产生一个新的空容器并将两个消息都作为它的
                      子节点. 这将捕获两者同为回复或同不为回复的情况,
                      然后使它们成为兄弟节点, 而不要将它们断为可能错误
                      的继承关系.

                        (那些回复帖子不带 ``Re:'' 的人以及回复信头没有
                        References 行的人将破坏这一规则. 那些人很恶心.)

            (使用帖子号或账号可以解决部分岐义的情况, 但不会总是很成功.) 

   6. 现在你已经完成线索化!
   
      特别的, 你不再需要容器对象里的 ``parent'' 了, 所以如果你希望数据
      变少, 结构更长久, 你会想归还一些存储空间的.

   7. 现在, 排序兄弟节点.
   
      在这里, 父子节点关系已经确立. 无论如何, 兄弟节点关系还未调整, 所
      以现在最后一次遍历树然后将兄弟节点按照日期, 发送者, 标题, 或其他
      什么的来排序. 这一步也可以在上面第四步结束时做, 但放在最后更清晰.
      如果你关心, 你还可以先排序消息然后再进行上面的算法, 不过那并不会
      有任何好处.
      
      
